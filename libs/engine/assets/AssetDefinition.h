#pragma once

// Asset Definition Types
// Data structures for asset definitions parsed from XML.
// Designed for C++ generators now with Lua drop-in compatibility later.

#include <cstdint>
#include <string>
#include <unordered_map>
#include <variant>
#include <vector>

namespace engine::assets {

	/// Asset type - how the shape is defined
	enum class AssetType {
		Simple,	   // Pre-made SVG file
		Procedural // Generated by C++ or Lua code
	};

	/// Distribution pattern for asset placement
	enum class Distribution {
		Uniform, // Random placement, no clustering
		Clumped, // Groups together in patches
		Spaced	 // Maintains minimum distance between instances
	};

	/// Asset complexity - affects rendering strategy
	enum class AssetComplexity {
		Simple, // Uses GPU instancing (grass, small flora)
		Complex // Individual tessellation (trees, buildings)
	};

	/// Animation type - how animation is applied
	enum class AnimationType {
		None,		 // No animation
		Parametric,	 // Simple sin-based wind sway (vertex shader)
		BezierDeform // Full Bezier curve deformation (CPU, expensive)
	};

	/// Rendering tier - determines batching strategy
	enum class RenderingTier {
		Instanced, // Single template + GPU instancing
		Batched,   // Multiple variants in batched draw calls
		Individual // Each instance drawn separately
	};

	/// Key-value parameter store for generator configuration.
	/// Supports string, float, and range values parsed from XML.
	class GeneratorParams {
	  public:
		GeneratorParams() = default;

		/// Get a string parameter
		std::string getString(const char* key, const std::string& defaultVal = "") const;

		/// Get a float parameter
		float getFloat(const char* key, float defaultVal = 0.0F) const;

		/// Get a float range parameter (min,max format in XML)
		void getFloatRange(const char* key, float& outMin, float& outMax, float defaultMin = 0.0F, float defaultMax = 1.0F) const;

		/// Get an integer parameter
		int32_t getInt(const char* key, int32_t defaultVal = 0) const;

		/// Set a string parameter
		void setString(const char* key, const std::string& value);

		/// Set a float parameter (stored as string for consistency)
		void setFloat(const char* key, float value);

		/// Check if a parameter exists
		bool has(const char* key) const;

	  private:
		std::unordered_map<std::string, std::string> params;
	};

	/// Animation parameters parsed from asset definition
	struct AnimationParams {
		bool		  enabled = false;
		AnimationType type = AnimationType::None;
		float		  windResponse = 0.3F;	   // How much wind affects this asset (0-1)
		float		  swayFrequencyMin = 0.5F; // Animation speed range
		float		  swayFrequencyMax = 1.0F;
	};

	/// Clumping parameters for Distribution::Clumped
	struct ClumpingParams {
		int32_t clumpSizeMin = 3;		// Number of instances per clump (min)
		int32_t clumpSizeMax = 12;		// Number of instances per clump (max)
		float	clumpRadiusMin = 0.5F;	// Radius in tile-widths within which clump instances are distributed (min)
		float	clumpRadiusMax = 2.0F;	// Radius in tile-widths within which clump instances are distributed (max)
		float	clumpSpacingMin = 3.0F; // Minimum distance in tiles between centers of different clumps
		float	clumpSpacingMax = 8.0F; // Maximum distance in tiles between centers of different clumps
	};

	/// Spacing parameters for Distribution::Spaced
	struct SpacingParams {
		float minDistance = 2.0F;  // Minimum tiles between instances
	};

	/// Per-biome placement configuration.
	/// Each biome can have different spawn behavior for the same asset.
	/// E.g., grass in grassland: dense/uniform; grass in forest: sparse/clumped.
	struct BiomePlacement {
		std::string	   biomeName;						   // "Grassland", "Forest", etc.
		float		   spawnChance = 0.3F;				   // Probability at each spawn point (0-1)
		Distribution   distribution = Distribution::Uniform;
		ClumpingParams clumping;  // Only used if distribution == Clumped
		SpacingParams  spacing;	  // Only used if distribution == Spaced
	};

	/// Placement parameters - where assets spawn in the world.
	/// Contains per-biome configuration for flexible spawn behavior.
	struct PlacementParams {
		std::vector<BiomePlacement> biomes;	 // Per-biome spawn configuration

		/// Find placement config for a specific biome name (returns nullptr if not found)
		[[nodiscard]] const BiomePlacement* findBiome(const std::string& biomeName) const {
			for (const auto& bp : biomes) {
				if (bp.biomeName == biomeName) {
					return &bp;
				}
			}
			return nullptr;
		}
	};

	/// Complete asset definition parsed from XML
	struct AssetDefinition {
		std::string		defName; // Unique identifier (e.g., "Flora_GrassBlade")
		std::string		label;	 // Human-readable name
		AssetType		assetType = AssetType::Procedural;
		std::string		generatorName; // Generator to use (e.g., "GrassBlade") - C++ generators
		std::string		scriptPath;	   // For Lua generators: path to Lua script (relative to assets/)
		std::string		svgPath;	   // For Simple assets: path to SVG file
		GeneratorParams params;		   // Parameters for generator
		AnimationParams animation;
		PlacementParams placement; // Where this asset spawns
		AssetComplexity complexity = AssetComplexity::Simple;
		RenderingTier	renderingTier = RenderingTier::Instanced;
		uint32_t		variantCount = 1; // Number of variants to pre-generate

		/// Check if this definition uses a Lua script generator
		[[nodiscard]] bool isLuaGenerator() const { return !scriptPath.empty(); }
	};

} // namespace engine::assets
