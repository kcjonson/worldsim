#pragma once

// EntityInfoModel - ViewModel for EntityInfoPanel
//
// Encapsulates:
// - Selection identity tracking (change detection)
// - Tab state (Status/Inventory for colonists)
// - Content generation via adapters
//
// The panel calls refresh() each frame, which returns what type of update
// is needed (if any). This enables the three-tier update optimization:
// - Visibility: show/hide panel
// - Structure: full relayout (different entity selected)
// - Values: just update progress bars (same entity, values changed)

#include "scenes/game/ui/components/InfoSlot.h"
#include "scenes/game/ui/components/Selection.h"
#include "scenes/game/ui/adapters/CraftingAdapter.h"

#include <assets/AssetRegistry.h>
#include <assets/RecipeRegistry.h>
#include <ecs/World.h>

#include <functional>
#include <string>

namespace world_sim {

/// Cached selection identity for detecting structural vs value-only updates
struct CachedSelection {
	enum class Type { None, Colonist, WorldEntity, CraftingStation };

	Type			  type = Type::None;
	ecs::EntityID	  colonistId{0};	 // For Colonist selection
	ecs::EntityID	  stationId{0};		 // For CraftingStation selection
	std::string		  worldEntityDef;	 // For WorldEntity selection
	std::string		  stationDefName;	 // For CraftingStation selection
	Foundation::Vec2 worldEntityPos;	 // For WorldEntity selection

	/// Check if this cache matches the given selection
	[[nodiscard]] bool matches(const Selection& selection) const;

	/// Update cache to match the given selection
	void update(const Selection& selection);
};

/// ViewModel for EntityInfoPanel
class EntityInfoModel {
  public:
	/// Type of update needed after refresh()
	enum class UpdateType {
		None,		 // No change, panel can skip update
		Values,		 // Same entity, just update progress bar values
		Structure,	 // Different entity or tab change, full relayout needed
		Show,		 // Panel was hidden, now needs to show
		Hide,		 // Panel was visible, now needs to hide
	};

	/// Callbacks needed for content generation
	struct Callbacks {
		std::function<void()> onTaskListToggle;	 // Toggle task list panel
		QueueRecipeCallback onQueueRecipe;		 // Queue recipe at station
	};

	/// Refresh model with current selection state
	/// @return Type of update the panel should perform
	[[nodiscard]] UpdateType refresh(
		const Selection& selection,
		const ecs::World& world,
		const engine::assets::AssetRegistry& assetRegistry,
		const engine::assets::RecipeRegistry& recipeRegistry,
		const Callbacks& callbacks
	);

	/// Get the current panel content (valid after refresh())
	[[nodiscard]] const PanelContent& content() const { return m_content; }

	/// Check if panel should be visible
	[[nodiscard]] bool isVisible() const { return m_visible; }

	/// Check if tabs should be shown (true for colonists)
	[[nodiscard]] bool showsTabs() const { return m_showTabs; }

	/// Get active tab ID
	[[nodiscard]] const std::string& activeTab() const { return m_activeTab; }

	/// Set active tab (called when tab bar is clicked)
	/// Triggers structure update on next refresh()
	void setActiveTab(const std::string& tabId);

  private:
	/// Generate content for colonist based on active tab
	[[nodiscard]] PanelContent getColonistContent(
		const ecs::World& world,
		ecs::EntityID entityId,
		const std::function<void()>& onTaskListToggle
	) const;

	/// Generate content for crafting station (status + recipes)
	[[nodiscard]] PanelContent getCraftingStationContent(
		const ecs::World& world,
		ecs::EntityID entityId,
		const std::string& stationDefName,
		const engine::assets::RecipeRegistry& recipeRegistry,
		const QueueRecipeCallback& onQueueRecipe
	) const;

	// State
	CachedSelection m_cachedSelection;
	std::string m_activeTab = "status";
	bool m_showTabs = false;
	bool m_visible = false;
	bool m_tabChangeRequested = false;

	// Cached content (generated by refresh())
	PanelContent m_content;
};

} // namespace world_sim
