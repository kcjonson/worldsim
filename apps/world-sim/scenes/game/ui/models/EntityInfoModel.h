#pragma once

// EntityInfoModel - ViewModel for EntityInfoView
//
// Encapsulates:
// - Selection identity tracking (change detection)
// - Content generation via adapters
//
// The panel calls refresh() each frame, which returns what type of update
// is needed (if any). This enables the three-tier update optimization:
// - Visibility: show/hide panel
// - Structure: full relayout (different entity selected)
// - Values: just update progress bars (same entity, values changed)

#include "scenes/game/ui/components/InfoSlot.h"
#include "scenes/game/world/selection/SelectionTypes.h"
#include "scenes/game/ui/adapters/CraftingAdapter.h"

#include <assets/AssetRegistry.h>
#include <assets/RecipeRegistry.h>
#include <ecs/World.h>

#include <functional>
#include <string>

namespace world_sim {

/// Cached selection identity for detecting structural vs value-only updates
struct CachedSelection {
	enum class Type { None, Colonist, WorldEntity, CraftingStation, Furniture };

	Type			  type = Type::None;
	ecs::EntityID	  colonistId{0};	 // For Colonist selection
	ecs::EntityID	  stationId{0};		 // For CraftingStation selection
	ecs::EntityID	  furnitureId{0};	 // For Furniture selection
	std::string		  worldEntityDef;	 // For WorldEntity selection
	std::string		  stationDefName;	 // For CraftingStation selection
	std::string		  furnitureDefName;	 // For Furniture selection
	Foundation::Vec2 worldEntityPos;	 // For WorldEntity selection
	bool			  furniturePackaged{false}; // For Furniture selection

	/// Check if this cache matches the given selection
	[[nodiscard]] bool matches(const Selection& selection) const;

	/// Update cache to match the given selection
	void update(const Selection& selection);
};

/// ViewModel for EntityInfoView
class EntityInfoModel {
  public:
	/// Type of update needed after refresh()
	enum class UpdateType {
		None,		 // No change, panel can skip update
		Values,		 // Same entity, just update progress bar values
		Structure,	 // Different entity or tab change, full relayout needed
		Show,		 // Panel was hidden, now needs to show
		Hide,		 // Panel was visible, now needs to hide
	};

	/// Callbacks needed for content generation
	struct Callbacks {
		std::function<void()> onDetails;	 // Open colonist details modal
		QueueRecipeCallback onQueueRecipe;	 // Queue recipe at station
		std::function<void()> onPlace;		 // Place packaged furniture
	};

	/// Refresh model with current selection state
	/// @return Type of update the panel should perform
	[[nodiscard]] UpdateType refresh(
		const Selection& selection,
		const ecs::World& world,
		const engine::assets::AssetRegistry& assetRegistry,
		const engine::assets::RecipeRegistry& recipeRegistry,
		const Callbacks& callbacks
	);

	/// Get the current panel content (valid after refresh())
	[[nodiscard]] const PanelContent& content() const { return contentData; }

	/// Check if panel should be visible
	[[nodiscard]] bool isVisible() const { return visible; }

	/// Check if selection is a colonist (for two-column layout)
	[[nodiscard]] bool isColonist() const { return isColonistFlag; }

  private:
	/// Generate content for colonist (two-column layout)
	[[nodiscard]] PanelContent getColonistContent(
		const ecs::World& world,
		ecs::EntityID entityId,
		const std::function<void()>& onDetails
	) const;

	/// Generate content for crafting station (status + recipes)
	[[nodiscard]] PanelContent getCraftingStationContent(
		const ecs::World& world,
		ecs::EntityID entityId,
		const std::string& stationDefName,
		const engine::assets::RecipeRegistry& recipeRegistry,
		const QueueRecipeCallback& onQueueRecipe
	) const;

	// State
	CachedSelection cachedSelection;
	bool isColonistFlag = false;
	bool visible = false;

	// Cached content (generated by refresh())
	PanelContent contentData;
};

} // namespace world_sim
